import { getContext, setContext, untrack } from 'svelte';
import { ConvexClient } from 'convex/browser';
import { getFunctionName } from 'convex/server';
import { convexToJson } from 'convex/values';
import { BROWSER } from 'esm-env';
const _contextKey = '$$_convexClient';
export const useConvexClient = () => {
    const client = getContext(_contextKey);
    if (!client) {
        throw new Error('No ConvexClient was found in Svelte context. Did you forget to call setupConvex() in a parent component?');
    }
    return client;
};
export const setConvexClientContext = (client) => {
    setContext(_contextKey, client);
};
export const setupConvex = (url, options = {}) => {
    if (!url || typeof url !== 'string') {
        throw new Error('Expected string url property for setupConvex');
    }
    const optionsWithDefaults = { disabled: !BROWSER, ...options };
    const client = new ConvexClient(url, optionsWithDefaults);
    setConvexClientContext(client);
    $effect(() => () => client.close());
};
// Note that swapping out the current Convex client is not supported.
/**
 * Subscribe to a Convex query and return a reactive query result object.
 * Pass reactive args object or a closure returning args to update args reactively.
 *
 * @param query - a FunctionRefernece like `api.dir1.dir2.filename.func`.
 * @param args - The arguments to the query function.
 * @param options - UseQueryOptions like `initialData` and `keepPreviousData`.
 * @returns an object containing data, isLoading, error, and isStale.
 */
export function useQuery(query, args, options = {}) {
    const client = useConvexClient();
    if (typeof query === 'string') {
        throw new Error('Query must be a functionReference object, not a string');
    }
    const state = $state({
        result: parseOptions(options).initialData,
        argsForLastResult: undefined,
        lastResult: undefined,
        haveArgsEverChanged: false
    });
    // When args change we need to unsubscribe to the old query and subscribe
    // to the new one.
    $effect(() => {
        const argsObject = parseArgs(args);
        const unsubscribe = client.onUpdate(query, argsObject, (dataFromServer) => {
            const copy = structuredClone(dataFromServer);
            state.result = copy;
            state.argsForLastResult = argsObject;
            state.lastResult = copy;
        }, (e) => {
            state.result = e;
            state.argsForLastResult = argsObject;
            // is it important to copy the error here?
            const copy = structuredClone(e);
            state.lastResult = copy;
        });
        return unsubscribe;
    });
    // Are the args (the query key) the same as the last args we received a result for?
    const sameArgsAsLastResult = $derived(!!state.argsForLastResult &&
        JSON.stringify(convexToJson(state.argsForLastResult)) ===
            JSON.stringify(convexToJson(parseArgs(args))));
    const staleAllowed = $derived(!!(parseOptions(options).keepPreviousData && state.lastResult));
    // Not reactive
    const initialArgs = parseArgs(args);
    // Once args change, move off of initialData.
    $effect(() => {
        if (!untrack(() => state.haveArgsEverChanged)) {
            if (JSON.stringify(convexToJson(parseArgs(args))) !== JSON.stringify(convexToJson(initialArgs))) {
                state.haveArgsEverChanged = true;
                const opts = parseOptions(options);
                if (opts.initialData !== undefined) {
                    state.argsForLastResult = $state.snapshot(initialArgs);
                    state.lastResult = parseOptions(options).initialData;
                }
            }
        }
    });
    // Return value or undefined; never an error object.
    const syncResult = $derived.by(() => {
        const opts = parseOptions(options);
        if (opts.initialData && !state.haveArgsEverChanged) {
            return state.result;
        }
        let value;
        try {
            value = client.disabled
                ? undefined
                : client.client.localQueryResult(getFunctionName(query), parseArgs(args));
        }
        catch (e) {
            if (!(e instanceof Error)) {
                // This should not happen by the API of localQueryResult().
                console.error('threw non-Error instance', e);
                throw e;
            }
            value = e;
        }
        // If state result has updated then it's time to check the for a new local value
        state.result;
        return value;
    });
    const result = $derived.by(() => {
        return syncResult !== undefined ? syncResult : staleAllowed ? state.lastResult : undefined;
    });
    const isStale = $derived(syncResult === undefined && staleAllowed && !sameArgsAsLastResult && result !== undefined);
    const data = $derived.by(() => {
        if (result instanceof Error) {
            return undefined;
        }
        return result;
    });
    const error = $derived.by(() => {
        if (result instanceof Error) {
            return result;
        }
        return undefined;
    });
    // This TypeScript cast promises data is not undefined if error and isLoading are checked first.
    return {
        get data() {
            return data;
        },
        get isLoading() {
            return error === undefined && data === undefined;
        },
        get error() {
            return error;
        },
        get isStale() {
            return isStale;
        }
    };
}
// args can be an object or a closure returning one
function parseArgs(args) {
    if (typeof args === 'function') {
        args = args();
    }
    return $state.snapshot(args);
}
// options can be an object or a closure
function parseOptions(options) {
    if (typeof options === 'function') {
        options = options();
    }
    return $state.snapshot(options);
}
