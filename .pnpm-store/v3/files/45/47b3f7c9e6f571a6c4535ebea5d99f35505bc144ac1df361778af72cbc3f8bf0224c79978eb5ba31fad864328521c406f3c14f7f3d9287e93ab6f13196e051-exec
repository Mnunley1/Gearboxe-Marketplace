#!/usr/bin/env node
var K=Object.defineProperty;var ot=Object.getOwnPropertyDescriptor;var it=Object.getOwnPropertyNames;var at=Object.prototype.hasOwnProperty;var X=(e=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(e,{get:(t,s)=>(typeof require<"u"?require:t)[s]}):e)(function(e){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+e+'" is not supported')}),ue=e=>t=>{var s=e[t];if(s)return s();throw new Error("Module not found in bundle: "+t)};var P=(e,t)=>()=>(e&&(t=e(e=0)),t);var Q=(e,t)=>{for(var s in t)K(e,s,{get:t[s],enumerable:!0})},rt=(e,t,s,o)=>{if(t&&typeof t=="object"||typeof t=="function")for(let n of it(t))!at.call(e,n)&&n!==s&&K(e,n,{get:()=>t[n],enumerable:!(o=ot(t,n))||o.enumerable});return e};var Z=e=>rt(K({},"__esModule",{value:!0}),e);import{access as lt,readFile as fe,writeFile as dt}from"fs/promises";import{parse as pt}from"jsonc-parser";var c,h,ge,R,mt,ut,M,m=P(()=>{"use strict";c=async e=>{try{return await lt(e),!0}catch{return!1}},h=async()=>{if(await c("pnpm-workspace.yaml"))return!0;try{let e=pt(await fe("package.json","utf-8"));return e?!!e.workspaces||!!e.workspace:!1}catch{return!1}},ge=`
888     888 888    88888888888 8888888b.         d8888  .d8888b. 8888888 88888888888 8888888888 
888     888 888        888     888   Y88b       d88888 d88P  Y88b  888       888     888        
888     888 888        888     888    888      d88P888 888    888  888       888     888        
888     888 888        888     888   d88P     d88P 888 888         888       888     8888888    
888     888 888        888     8888888P"     d88P  888 888         888       888     888        
888     888 888        888     888 T88b     d88P   888 888    888  888       888     888        
Y88b. .d88P 888        888     888  T88b   d8888888888 Y88b  d88P  888       888     888        
 "Y88888P"  88888888   888     888   T88b d88P     888  "Y8888P" 8888888     888     8888888888
`,R=async({dependencies:e,devDependencies:t})=>{let s=await fe("package.json","utf8"),o=JSON.parse(s),n={...o,devDependencies:{...o.devDependencies,...t},dependencies:{...o.dependencies,...e}};await dt("package.json",JSON.stringify(n,null,2))},mt=/[ $(){}[\]&|;<>!"'`*?#~]/,ut=/'/g,M=e=>e.map(t=>mt.test(t)?`'${t.replace(ut,"'\\''")}' `:t)});var Ge={};Q(Ge,{husky:()=>C});import{mkdir as Zt,readFile as es,writeFile as ze}from"fs/promises";import{addDevDependency as ts,dlxCommand as Be}from"nypm";var qe,G,C,re=P(()=>{"use strict";m();qe=e=>`#!/bin/sh
# Exit on any error
set -e

# Check if there are any staged files
if [ -z "$(git diff --cached --name-only)" ]; then
  echo "No staged files to format"
  exit 0
fi

# Store the hash of staged changes to detect modifications
STAGED_HASH=$(git diff --cached | sha256sum | cut -d' ' -f1)

# Save list of staged files (handling all file states)
STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACMR)
PARTIALLY_STAGED=$(git diff --name-only)

# Stash unstaged changes to preserve working directory
# --keep-index keeps staged changes in working tree
git stash push --quiet --keep-index --message "pre-commit-stash" || true
STASHED=$?

# Run formatter on the staged files
${e}
FORMAT_EXIT_CODE=$?

# Restore working directory state
if [ $STASHED -eq 0 ]; then
  # Re-stage the formatted files
  if [ -n "$STAGED_FILES" ]; then
    echo "$STAGED_FILES" | while IFS= read -r file; do
      if [ -f "$file" ]; then
        git add "$file"
      fi
    done
  fi
  
  # Restore unstaged changes
  git stash pop --quiet || true
  
  # Restore partial staging if files were partially staged
  if [ -n "$PARTIALLY_STAGED" ]; then
    for file in $PARTIALLY_STAGED; do
      if [ -f "$file" ] && echo "$STAGED_FILES" | grep -q "^$file$"; then
        # File was partially staged - need to unstage the unstaged parts
        git restore --staged "$file" 2>/dev/null || true
        git add -p "$file" < /dev/null 2>/dev/null || git add "$file"
      fi
    done
  fi
else
  # No stash was created, just re-add the formatted files
  if [ -n "$STAGED_FILES" ]; then
    echo "$STAGED_FILES" | while IFS= read -r file; do
      if [ -f "$file" ]; then
        git add "$file"
      fi
    done
  fi
fi

# Check if staged files actually changed
NEW_STAGED_HASH=$(git diff --cached | sha256sum | cut -d' ' -f1)
if [ "$STAGED_HASH" != "$NEW_STAGED_HASH" ]; then
  echo "\u2728 Files formatted by Ultracite"
fi

exit $FORMAT_EXIT_CODE
`,G="./.husky/pre-commit",C={exists:()=>c(G),install:async e=>{await ts("husky",{packageManager:e,workspace:await h()})},create:async e=>{await Zt(".husky",{recursive:!0});let t=Be(e,"ultracite",{args:["fix"],short:e==="npm"}),s=qe(t);await ze(G,s)},update:async e=>{let t=await es(G,"utf-8"),s=Be(e,"ultracite",{args:["fix"],short:e==="npm"}),o=qe(s);await ze(G,`${t}
${o}`)}}});var Ye={};Q(Ye,{lefthook:()=>j});import{execSync as ss}from"child_process";import{readFile as ns,writeFile as E}from"fs/promises";import{addDevDependency as os,dlxCommand as He}from"nypm";var is,as,Ve,b,We,j,ce=P(()=>{"use strict";m();is=/(pre-commit:\s*\n\s*jobs:\s*\n)/,as=/(pre-commit:\s*\n)/,Ve=e=>He(e,"ultracite",{args:["fix"],short:e==="npm"}),b="./lefthook.yml",We=e=>`pre-commit:
  jobs:
    - run: ${Ve(e)}
      glob: 
        - "*.js"
        - "*.jsx"
        - "*.ts"
        - "*.tsx"
        - "*.json"
        - "*.jsonc"
        - "*.css"
      stage_fixed: true
`,j={exists:()=>c(b),install:async e=>{await os("lefthook",{packageManager:e,workspace:await h()});let t=He(e,"lefthook",{args:["install"],short:e==="npm"});ss(t)},create:async e=>{let t=We(e);await E(b,t)},update:async e=>{let t=await ns(b,"utf-8"),s=Ve(e),o=We(e);if(t.includes(s))return;if(t.startsWith("# EXAMPLE USAGE:")){await E(b,o);return}if(t.includes("pre-commit:"))if(t.includes("jobs:")){let a=`    - run: ${s}
      glob: 
        - "*.js"
        - "*.jsx"
        - "*.ts"
        - "*.tsx"
        - "*.json"
        - "*.jsonc"
        - "*.css"
      stage_fixed: true`,i=t.replace(is,`$1${a}
`);await E(b,i)}else{let a=`  jobs:
    - run: ${s}
      glob: 
        - "*.js"
        - "*.jsx"
        - "*.ts"
        - "*.tsx"
        - "*.json"
        - "*.jsonc"
        - "*.css"
      stage_fixed: true`,i=t.replace(as,`$1${a}
`);await E(b,i)}else await E(b,`${t}
${o}`)}}});var rs,le=P(()=>{rs=ue({"./husky.ts":()=>(re(),Z(Ge)),"./lefthook.ts":()=>(ce(),Z(Ye)),"./lint-staged.ts":()=>(de(),Z(Ke))})});var Ke={};Q(Ke,{lintStaged:()=>S});import{readFile as W,writeFile as k}from"fs/promises";import{pathToFileURL as cs}from"url";import $ from"deepmerge";import{parse as me}from"jsonc-parser";import{addDevDependency as ls,dlxCommand as ds}from"nypm";var y,Xe,ps,ms,us,fs,gs,hs,ys,ws,vs,pe,bs,S,de=P(()=>{"use strict";m();le();y=e=>({"*.{js,jsx,ts,tsx,json,jsonc,css,scss,md,mdx}":[ds(e,"ultracite",{args:["fix"],short:e==="npm"})]}),Xe=["./package.json","./.lintstagedrc.json","./.lintstagedrc.js","./.lintstagedrc.cjs","./.lintstagedrc.mjs","./lint-staged.config.js","./lint-staged.config.cjs","./lint-staged.config.mjs","./.lintstagedrc.yaml","./.lintstagedrc.yml","./.lintstagedrc"],ps=(e,t,s,o)=>{let n=e.trim();if(n.includes(":")&&!n.startsWith("-")){s&&o.length>0&&(t[s]=o);let[a,...i]=n.split(":"),r=i.join(":").trim(),p=a.trim().replace(/['"]/g,"");return r&&r!==""?(r.startsWith("[")&&r.endsWith("]")?t[p]=r.slice(1,-1).split(",").map(g=>g.trim().replace(/['"]/g,"")):t[p]=r.replace(/['"]/g,""),{newCurrentKey:null,newCurrentArray:[]}):{newCurrentKey:p,newCurrentArray:[]}}if(n.startsWith("-")&&s){let a=[...o,n.slice(1).trim().replace(/['"]/g,"")];return{newCurrentKey:s,newCurrentArray:a}}return{newCurrentKey:s,newCurrentArray:o}},ms=e=>{let t=e.split(`
`).filter(a=>a.trim()&&!a.trim().startsWith("#")),s={},o=null,n=[];for(let a of t){let i=ps(a,s,o,n);o=i.newCurrentKey,n=i.newCurrentArray}return o&&n.length>0&&(s[o]=n),s},us=e=>{let t="";for(let[s,o]of Object.entries(e))if(Array.isArray(o)){t+=`${s}:
`;for(let n of o)t+=`  - '${n}'
`}else t+=`${s}: '${o}'
`;return t},fs=async()=>{try{let e=me(await W("./package.json","utf-8"));return e?e.type==="module":!1}catch{return!1}},gs=async e=>{let t=me(await W("./package.json","utf-8"));t&&(t["lint-staged"]?t["lint-staged"]=$(t["lint-staged"],y(e)):t["lint-staged"]=y(e),await k("./package.json",JSON.stringify(t,null,2)))},hs=async(e,t)=>{let s=await W(e,"utf-8"),o=me(s);if(!o)return;let n=$(o,y(t));await k(e,JSON.stringify(n,null,2))},ys=async(e,t)=>{let s=await W(e,"utf-8"),o=ms(s);if(!o)return;let n=$(o,y(t));await k(e,us(n))},ws=async(e,t)=>{let n=(await import(cs(e).href)).default||{},a=$(n,y(t)),i=`export default ${JSON.stringify(a,null,2)};
`;await k(e,i)},vs=async(e,t)=>{delete X.cache[X.resolve(`./${e}`)];let s=rs(`./${e}`),o=$(s,y(t)),n=`module.exports = ${JSON.stringify(o,null,2)};
`;await k(e,n)},pe=async e=>{await k(".lintstagedrc.json",JSON.stringify(y(e),null,2))},bs=async(e,t)=>{if(e==="./package.json"){await gs(t);return}if(e.endsWith(".json")||e==="./.lintstagedrc"){await hs(e,t);return}if(e.endsWith(".yaml")||e.endsWith(".yml")){await ys(e,t);return}let s=await fs();if(e.endsWith(".mjs")||e.endsWith(".js")&&s){try{await ws(e,t)}catch{await pe(t)}return}if(e.endsWith(".cjs")||e.endsWith(".js")&&!s)try{await vs(e,t)}catch{await pe(t)}},S={exists:async()=>{for(let e of Xe)if(await c(e))return!0;return!1},install:async e=>{await ls("lint-staged",{packageManager:e,workspace:await h()})},create:async e=>{await k(".lintstagedrc.json",JSON.stringify(y(e),null,2))},update:async e=>{let t=null;for(let s of Xe)if(await c(s)){t=s;break}if(!t){await pe(e);return}await bs(t,e)}}});import{initTRPC as Ts}from"@trpc/server";import{createCli as _s}from"trpc-cli";import l from"zod";var w={name:"ultracite",description:"The AI-ready formatter that helps you write and generate code faster.",version:"6.0.3",type:"module",bin:{ultracite:"dist/index.js"},files:["config","dist","README.md"],scripts:{build:"tsup",test:"vitest run","test:coverage":"vitest run --coverage"},exports:{"./*":"./config/*/biome.jsonc"},author:"Hayden Bleasel <hello@haydenbleasel.com>",bugs:{url:"https://github.com/haydenbleasel/ultracite/issues"},homepage:"https://github.com/haydenbleasel/ultracite#readme",keywords:["ultracite","biome","linter","formatter","fixer"],license:"MIT",publishConfig:{access:"public",registry:"https://registry.npmjs.org/"},repository:{type:"git",url:"git+https://github.com/haydenbleasel/ultracite.git"},devDependencies:{"@biomejs/biome":"2.3.0","@types/node":"^24.9.1","@vitest/coverage-v8":"4.0.3",tsup:"^8.5.0",turbo:"^2.5.8",vitest:"^4.0.3"},dependencies:{"@clack/prompts":"^0.11.0","@trpc/server":"^11.6.0",deepmerge:"^4.3.1","jsonc-parser":"^3.3.1",nypm:"^0.6.2","trpc-cli":"^0.12.0",zod:"^4.1.12"},packageManager:"pnpm@10.19.0"};m();import{spawnSync as ft}from"child_process";import he from"process";var ee=e=>{let t=["npx","@biomejs/biome","check","--no-errors-on-unmatched"];e.length>0?t.push(...M(e)):t.push("./");let s=t.join(" "),o=ft(s,{stdio:"inherit",shell:!0});o.error&&(console.error("Failed to run Ultracite:",o.error.message),he.exit(1)),o.status!==0&&he.exit(o.status??1)};import{spawnSync as At}from"child_process";import{existsSync as A}from"fs";import{readFile as Ne}from"fs/promises";import{join as U}from"path";import{parse as Ut}from"jsonc-parser";m();import{readFile as ye,unlink as gt,writeFile as ht}from"fs/promises";import{parse as we}from"jsonc-parser";import{removeDependency as yt}from"nypm";var T=[".eslintrc",".eslintrc.js",".eslintrc.json",".eslintrc.yml",".eslintrc.yaml",".eslintrc.config.js","eslint.config.js","eslint.config.mjs","eslint.config.cjs",".eslintignore"],ve=async()=>{try{let e=await ye("package.json","utf-8"),t=we(e);if(!t||typeof t!="object")return[];let s=t.dependencies||{},o=t.devDependencies||{},n={...s,...o};return Object.keys(n).filter(a=>a.includes("eslint"))}catch{return[]}},wt=async(e,t)=>{if(t.length!==0)try{for(let s of t)await yt(s,{packageManager:e})}catch(s){console.warn(s)}},vt=async()=>{let e=[];for(let t of T)if(await c(t))try{await gt(t),e.push(t)}catch(s){console.warn(s)}return e},bt=async()=>{let e="./.vscode/settings.json";if(!await c(e))return!1;try{let t=await ye(e,"utf-8"),s=we(t);if(!s||typeof s!="object")return!1;let o=!1,n={...s},a=["eslint.enable","eslint.format.enable","eslint.validate","eslint.workingDirectories","eslint.codeAction.showDocumentation","eslint.run","eslint.autoFixOnSave","eslint.quiet","eslint.packageManager","eslint.options","eslint.trace.server"];for(let i of a)i in n&&(delete n[i],o=!0);if("editor.codeActionsOnSave"in n){let i=n["editor.codeActionsOnSave"];if(i&&typeof i=="object"){let r=["source.fixAll.eslint","source.organizeImports.eslint"];for(let p of r)p in i&&(delete i[p],o=!0);Object.keys(i).length===0&&(n["editor.codeActionsOnSave"]=void 0)}}return o?(await ht(e,JSON.stringify(n,null,2)),!0):!1}catch(t){return console.warn(t),!1}},kt=async()=>{if((await ve()).length>0)return!0;for(let t of T)if(await c(t))return!0;return!1},te={hasEsLint:kt,remove:async e=>{let t=await ve();await wt(e,t);let s=await vt(),o=await bt();return{packagesRemoved:t,filesRemoved:s,vsCodeCleaned:o}}};m();import{readFile as be,unlink as xt,writeFile as Nt}from"fs/promises";import{parse as ke}from"jsonc-parser";import{removeDependency as Ct}from"nypm";var _=[".prettierrc",".prettierrc.js",".prettierrc.json",".prettierrc.yml",".prettierrc.yaml",".prettierrc.config.js","prettier.config.js","prettier.config.mjs",".prettierignore"],xe=async()=>{try{let e=await be("package.json","utf-8"),t=ke(e);if(!t||typeof t!="object")return[];let s=t.dependencies||{},o=t.devDependencies||{},n={...s,...o};return Object.keys(n).filter(a=>a.includes("prettier"))}catch{return[]}},jt=async(e,t)=>{if(t.length!==0)try{for(let s of t)await Ct(s,{packageManager:e})}catch(s){console.warn(s)}},St=async()=>{let e=[];for(let t of _)if(await c(t))try{await xt(t),e.push(t)}catch(s){console.warn(s)}return e},Pt=async()=>{let e="./.vscode/settings.json";if(!await c(e))return!1;try{let t=await be(e,"utf-8"),s=ke(t);if(!s||typeof s!="object")return!1;let o=!1,n={...s},a=["editor.defaultFormatter","prettier.enable","prettier.requireConfig","prettier.configPath","prettier.printWidth","prettier.tabWidth","prettier.useTabs","prettier.semi","prettier.singleQuote","prettier.quoteProps","prettier.trailingComma","prettier.bracketSpacing","prettier.arrowParens","prettier.endOfLine"];for(let r of a)r in n&&(r==="editor.defaultFormatter"&&n[r]==="esbenp.prettier-vscode"||r!=="editor.defaultFormatter")&&(delete n[r],o=!0);let i=Object.keys(n).filter(r=>r.startsWith("[")&&r.includes("javascript"));for(let r of i){let p=n[r];p&&typeof p=="object"&&"editor.defaultFormatter"in p&&p["editor.defaultFormatter"]==="esbenp.prettier-vscode"&&(delete p["editor.defaultFormatter"],o=!0,Object.keys(p).length===0&&delete n[r])}return o?(await Nt(e,JSON.stringify(n,null,2)),!0):!1}catch(t){return console.warn(t),!1}},Rt=async()=>{if((await xe()).length>0)return!0;for(let t of _)if(await c(t))return!0;return!1},se={hasPrettier:Rt,remove:async e=>{let t=await xe();await jt(e,t);let s=await St(),o=await Pt();return{packagesRemoved:t,filesRemoved:s,vsCodeCleaned:o}}};var Ft=()=>{let e=At("npx @biomejs/biome --version",{shell:!0,encoding:"utf-8"});return e.status===0&&e.stdout?{name:"Biome installation",status:"pass",message:`Biome is installed (${e.stdout.trim()})`}:{name:"Biome installation",status:"fail",message:"Biome is not installed or not accessible"}},Et=async()=>{let e=U(process.cwd(),"biome.json"),t=U(process.cwd(),"biome.jsonc"),s=null;if(A(e)?s=e:A(t)&&(s=t),!s)return{name:"Biome configuration",status:"fail",message:"No biome.json or biome.jsonc file found"};try{let o=await Ne(s,"utf-8"),n=Ut(o);return Array.isArray(n?.extends)&&n.extends.includes("ultracite/core")?{name:"Biome configuration",status:"pass",message:"biome.json(c) extends ultracite/core"}:{name:"Biome configuration",status:"warn",message:"biome.json(c) exists but doesn't extend ultracite/core"}}catch{return{name:"Biome configuration",status:"fail",message:"Could not parse biome.json(c) file"}}},$t=async()=>{let e=U(process.cwd(),"package.json");if(!A(e))return{name:"Ultracite dependency",status:"warn",message:"No package.json found"};try{let t=JSON.parse(await Ne(e,"utf-8")),s=t.dependencies?.ultracite||t.devDependencies?.ultracite||t.peerDependencies?.ultracite;return s?{name:"Ultracite dependency",status:"pass",message:`Ultracite is in package.json (${s})`}:{name:"Ultracite dependency",status:"warn",message:"Ultracite not found in package.json dependencies"}}catch{return{name:"Ultracite dependency",status:"warn",message:"Could not parse package.json"}}},It=()=>{let e=_.some(s=>A(U(process.cwd(),s))),t=T.some(s=>A(U(process.cwd(),s)));if(e||t){let s=[];return e&&s.push("Prettier"),t&&s.push("ESLint"),{name:"Conflicting tools",status:"warn",message:`Found potentially conflicting tools: ${s.join(", ")}`}}return{name:"Conflicting tools",status:"pass",message:"No conflicting formatting/linting tools found"}},Ce=async()=>{let e=[];console.log(`\u{1FA7A} Running Ultracite doctor...
`),e.push(Ft()),e.push(await Et()),e.push(await $t()),e.push(It());let t=e.filter(n=>n.status==="pass").length,s=e.filter(n=>n.status==="fail").length,o=e.filter(n=>n.status==="warn").length;for(let n of e){let a;n.status==="pass"?a="\u2705":n.status==="fail"?a="\u274C":a="\u26A0\uFE0F",console.log(`${a} ${n.name}: ${n.message}`)}console.log(`
\u{1F4CA} Summary:`),console.log(`   ${t} passed, ${o} warnings, ${s} failed`),s>0&&(console.log(`
\u{1F4A1} To fix issues, run: npx ultracite init`),process.exit(1)),o>0?console.log(`
\u{1F4A1} Some optional improvements available. Run 'npx ultracite init' to configure.`):console.log(`
\u2728 Everything looks good!`)};m();import{spawnSync as Ot}from"child_process";import je from"process";var ne=(e,t={})=>{let s=["npx","@biomejs/biome","check","--write","--no-errors-on-unmatched"];t.unsafe&&s.push("--unsafe"),e.length>0?s.push(...M(e)):s.push("./");let o=s.join(" "),n=Ot(o,{stdio:"inherit",shell:!0});n.error&&(console.error("Failed to run Ultracite:",n.error.message),je.exit(1)),n.status!==0&&je.exit(n.status??1)};import{packageManagers as Dt}from"nypm";var v={packageManagers:Dt.map(e=>e.name),editorConfigs:["vscode","zed"],agents:["vscode-copilot","cursor","windsurf","zed","claude","codex","kiro","cline","amp","aider","firebase-studio","open-hands","gemini-cli","junie","augmentcode","kilo-code","goose","roo-code"],integrations:["husky","lefthook","lint-staged"],frameworks:["react","next","solid","vue","svelte","qwik","remix","angular","astro"],migrations:["eslint","prettier"]};import x from"process";import{cancel as I,intro as Cs,isCancel as O,log as Y,multiselect as D,spinner as f}from"@clack/prompts";import{addDevDependency as js,detectPackageManager as Ss}from"nypm";import{mkdir as Mt,readFile as Tt,writeFile as J}from"fs/promises";import{dirname as _t}from"path";var Se={"vscode-copilot":{path:"./.github/copilot-instructions.md",header:`---
applyTo: "**/*.{ts,tsx,js,jsx}"
---`,appendMode:!0},cursor:{path:"./.cursor/rules/ultracite.mdc",header:`---
description: Ultracite Rules - AI-Ready Formatter and Linter
globs: "**/*.{ts,tsx,js,jsx}"
alwaysApply: true
---`},windsurf:{path:"./.windsurf/rules/ultracite.md"},zed:{path:"./.rules",appendMode:!0},claude:{path:"./.claude/CLAUDE.md",appendMode:!0},codex:{path:"./AGENTS.md",appendMode:!0},kiro:{path:"./.kiro/steering/ultracite.md"},cline:{path:"./.clinerules",appendMode:!0},amp:{path:"./AGENT.md",appendMode:!0},aider:{path:"./ultracite.md"},"firebase-studio":{path:"./.idx/airules.md",appendMode:!0},"open-hands":{path:"./.openhands/microagents/repo.md",appendMode:!0},"gemini-cli":{path:"./GEMINI.md",appendMode:!0},junie:{path:"./.junie/guidelines.md",appendMode:!0},augmentcode:{path:"./.augment/rules/ultracite.md"},"kilo-code":{path:"./.kilocode/rules/ultracite.md"},goose:{path:"./.goosehints",appendMode:!0},"roo-code":{path:"./.roo/rules/ultracite.md",appendMode:!0}};m();var Pe=["Avoid `accessKey` attr and distracting els",'No `aria-hidden="true"` on focusable els',"No ARIA roles, states, props on unsupported els","Use `scope` prop only on `<th>` els","No non-interactive ARIA roles on interactive els","Label els need text and associated input","No event handlers on non-interactive els","No interactive ARIA roles on non-interactive els","No `tabIndex` on non-interactive els","No positive integers on `tabIndex` prop","No `image`, `picture`, or `photo` in img alt props","No explicit role matching implicit role","Valid role attrs on static, visible els w/ click handlers","Use `title` el for `svg` els","Provide meaningful alt text for all els requiring it","Anchors need accessible content","Assign `tabIndex` to non-interactive els w/ `aria-activedescendant`","Include all required ARIA attrs for els w/ ARIA roles","Use valid ARIA props for the el's role","Use `type` attr on `button` els","Make els w/ interactive roles and handlers focusable","Heading els need accessible content","Add `lang` attr to `html` el","Use `title` attr on `iframe` els","Pair `onClick` w/ `onKeyUp`, `onKeyDown`, or `onKeyPress`","Pair `onMouseOver`/`onMouseOut` w/ `onFocus`/`onBlur`","Add caption tracks to audio and video els","Use semantic els vs role attrs","All anchors must be valid and navigable","Use valid, non-abstract ARIA props, roles, states, and values","Use valid values for `autocomplete` attr","Use correct ISO language codes in `lang` attr","Include generic font family in font families","No consecutive spaces in regex literals","Avoid `arguments`, comma op, and primitive type aliases","No empty type params in type aliases and interfaces","Keep fns under Cognitive Complexity limit","Limit nesting depth of `describe()` in tests","No unnecessary boolean casts or callbacks on `flatMap`","Use `for...of` vs `Array.forEach`","No classes w/ only static members","No `this` and `super` in static contexts","No unnecessary catch clauses, ctors, `continue`, escape sequences in regex literals, fragments, labels, or nested blocks","No empty exports","No renaming imports, exports, or destructured assignments to same name","No unnecessary string/template literal concatenation or useless cases in switch stmts, `this` aliasing, or `String.raw` without escape sequences","Use simpler alternatives to ternary ops if possible","No `any` or `unknown` as type constraints or initializing vars to `undefined`","Avoid `void` op","Use arrow fns vs function exprs","Use `Date.now()` for milliseconds since Unix Epoch","Use `.flatMap()` vs `map().flat()`","Use `indexOf`/`lastIndexOf` vs `findIndex`/`findLastIndex` for simple lookups","Use literal property access vs computed property access","Use binary, octal, or hex literals vs `parseInt()`","Use concise optional chains vs chained logical exprs","Use regex literals vs `RegExp` ctor","Use base 10 or underscore separators for number literal object member names","Remove redundant terms from logical exprs","Use `while` loops vs `for` loops if initializer and update aren't needed","No reassigning `const` vars or constant exprs in conditions","No `Math.min`/`Math.max` to clamp values where result is constant","No return values from ctors or setters","No empty character classes in regex literals or destructuring patterns","No `__dirname` and `__filename` in global scope","No calling global object props as fns or declaring fns and `var` accessible outside their block","Instantiate builtins correctly","Use `super()` correctly in classes","Use standard direction values for linear gradient fns","Use valid named grid areas in CSS Grid Layouts","Use `@import` at-rules in valid positions","No vars and params before their decl","Include `var` fn for CSS vars","No `\\8` and `\\9` escape sequences in strings","No literal numbers that lose precision, configured els, or assigning where both sides are same","Compare string case modifications w/ compliant values","No lexical decls in switch clauses or undeclared vars","No unknown CSS value fns, media feature names, props, pseudo-class/pseudo-element selectors, type selectors, or units","No unmatchable An+B selectors or unreachable code","Call `super()` exactly once before accessing `this` in ctors","No control flow stmts in `finally` blocks","No optional chaining where `undefined` is not allowed","No unused fn params, imports, labels, private class members, or vars","No return values from fns w/ return type `void`","Specify all dependencies correctly in React hooks and names for GraphQL operations","Call React hooks from top level of component fns","Use `isNaN()` when checking for NaN",'Use `{ type: "json" }` for JSON module imports',"Use radix arg w/ `parseInt()`","Start JSDoc comment lines w/ single asterisk","Move `for` loop counters in right direction","Compare `typeof` exprs to valid values","Include `yield` in generator fns","No importing deprecated exports, duplicate dependencies, or Promises where they're likely a mistake","No non-null assertions after optional chaining or shadowing vars from outer scope","No expr stmts that aren't fn calls or assignments or useless `undefined`","Add `href` attr to `<a>` els and `width`/`height` attrs to `<img>` els","Use consistent arrow fn bodies and either `interface` or `type` consistently","Specify deletion date w/ `@deprecated` directive","Make switch-case stmts exhaustive and limit number of fn params","Sort CSS utility classes","No spread syntax on accumulators, barrel files, `delete` op, dynamic namespace import access, namespace imports, or duplicate polyfills from Polyfill.io","Use `preconnect` attr w/ Google Fonts","Declare regex literals at top level",'Add `rel="noopener"` when using `target="_blank"`',"No dangerous JSX props","No both `children` and `dangerouslySetInnerHTML` props","No global `eval()`","No callbacks in async tests and hooks, TS enums, exporting imported vars, type annotations for vars initialized w/ literals, magic numbers without named constants, or TS namespaces","No negating `if` conditions when there's an `else` clause, nested ternary exprs, non-null assertions (`!`), reassigning fn params, parameter props in class ctors, specified global var names, importing specified modules, or specified user-defined types","No constants where value is upper-case version of name, template literals without interpolation or special chars, `else` blocks when `if` block breaks early, yoda exprs, or `Array` ctors","Use `String.slice()` vs `String.substr()` and `String.substring()`","Use `as const` vs literal type annotations and `at()` vs integer index access","Follow curly brace conventions","Use `else if` vs nested `if` in `else` clauses and single `if` vs nested `if` clauses","Use `T[]` vs `Array<T>`","Use `new` for all builtins except `String`, `Number`, and `Boolean`","Use consistent accessibility modifiers on class props and methods","Declare object literals consistently","Use `const` for vars only assigned once","Put default and optional fn params last","Include `default` clause in switch stmts","Specify reason arg w/ `@deprecated` directive","Explicitly initialize each enum member value","Use `**` op vs `Math.pow`","Use `export type` and `import type` for types","Use kebab-case, ASCII filenames","Use `for...of` vs `for` loops w/ array index access","Use `<>...</>` vs `<Fragment>...</Fragment>`","Capitalize all enum values","Place getters and setters for same prop adjacent","Use literal values for all enum members","Use `node:assert/strict` vs `node:assert`","Use `node:` protocol for Node.js builtin modules","Use `Number` props vs global ones","Use numeric separators in numeric literals","Use object spread vs `Object.assign()` for new objects","Mark members `readonly` if never modified outside ctor","No extra closing tags for comps without children","Use assignment op shorthand","Use fn types vs object types w/ call signatures","Add description param to `Symbol()`","Use template literals vs string concatenation","Use `new` when throwing an error","No throwing non-`Error` values","Use `String.trimStart()`/`String.trimEnd()` vs `String.trimLeft()`/`String.trimRight()`","No overload signatures that can be unified","No lower specificity selectors after higher specificity selectors","No `@value` rule in CSS modules","No `alert`, `confirm`, and `prompt`","Use standard constants vs approximated literals","No assigning in exprs","No async fns as Promise executors","No `!` pattern in first position of `files.includes`","No bitwise ops","No reassigning exceptions in catch clauses","No reassigning class members","No inserting comments as text nodes","No comparing against `-0`","No labeled stmts that aren't loops","No `void` type outside generic or return types","No `console`","No TS const enums","No exprs where op doesn't affect value","No control chars in regex literals","No `debugger`","No assigning directly to `document.cookie`","Use `===` and `!==`","No duplicate `@import` rules, case labels, class members, custom props, conditions in if-else-if chains, GraphQL fields, font family names, object keys, fn param names, decl block props, keyframe selectors, or describe hooks","No empty CSS blocks, block stmts, static blocks, or interfaces","No letting vars evolve into `any` type through reassignments","No `any` type","No `export` or `module.exports` in test files","No misusing non-null assertion op (`!`)","No fallthrough in switch clauses","No focused or disabled tests","No reassigning fn decls","No assigning to native objects and read-only global vars","Use `Number.isFinite` and `Number.isNaN` vs global `isFinite` and `isNaN`","No implicit `any` type on var decls","No assigning to imported bindings","No `!important` within keyframe decls","No irregular whitespace chars","No labels that share name w/ var","No chars made w/ multiple code points in char classes","Use `new` and `constructor` properly","Place assertion fns inside `it()` fn calls","No shorthand assign when var appears on both sides","No octal escape sequences in strings","No `Object.prototype` builtins directly","No `quickfix.biome` in editor settings","No redeclaring vars, fns, classes, and types in same scope","No redundant `use strict`","No comparing where both sides are same","No shadowing restricted names","No shorthand props that override related longhand props","No sparse arrays","No template literal placeholder syntax in regular strings","No `then` prop","No `@ts-ignore` directive","No `let` or `var` vars that are read but never assigned","No unknown at-rules","No merging interface and class decls unsafely","No unsafe negation (`!`)","No unnecessary escapes in strings or useless backreferences in regex literals","No `var`","No `with` stmts","No separating overload signatures","Use `await` in async fns","Use correct syntax for ignoring folders in config","Put default clauses in switch stmts last","Pass message value when creating built-in errors","Return value from get methods","Use recommended display strategy w/ Google Fonts","Include `if` stmt in for-in loops","Use `Array.isArray()` vs `instanceof Array`","Return consistent values in iterable callbacks","Use `namespace` keyword vs `module` keyword","Use digits arg w/ `Number#toFixed()`","Use static `Response` methods vs `new Response()`","Use `use strict` directive in script files"],Re=["No passing children as props. Nest children between opening and closing tags","No defining comps inside other comps","No reassigning props in React comps","No using return value from `ReactDOM.render()`","No adding children to void els like `<img>` and `<br>`","Specify all dependencies correctly in React hooks","Call React hooks from top level of comp fns only","Add `key` prop to els in iterables","No legacy `React.forwardRef`. Use ref as prop instead (React 19+)","Use fn comps vs class comps","No array indices as keys","No duplicate props in JSX","No semicolons that change JSX el semantics"],Ae=["No async client comps. Use server comps for async operations","Use Next.js `<Image>` comp vs `<img>` el","Use Next.js `next/head` or App Router metadata API vs `<head>` el","No importing `next/document` in page files","No importing `next/head` in `_document.tsx`. Use `<Head>` from `next/document` instead"],Ue=["No `useVisibleTask$`. Use `useTask$` or `useResource$` instead","Use `class` object syntax vs string concatenation for dynamic classes","Explicitly capture vars from outer scopes in Qwik's `$` fns","Use Qwik-specific methods and APIs correctly","No React-specific props like `className` and `htmlFor`. Use `class` and `for` instead"],Fe=["No destructuring props in Solid comps. Access props directly","Use `<For>` comp for iterating over arrays","No React-specific props like `className` and `htmlFor`. Use `class` and `for` instead"],Ee=["No React-specific props like `className` and `htmlFor`. Use `class` and `for` instead"],$e=["No object decls for `data` option. Use fn that returns object","No duplicate keys in Vue comp options","No Vue reserved keys like `$data`, `$props`, and `$el` in comp options","No Vue reserved props like `key`, `ref`, and `is` as custom comp props","Use multi-word comp names to avoid conflicts w/ HTML els","No React-specific props like `className` and `htmlFor`. Use `class` and `for` instead"],Ie=[],Oe=[],De=["Use `let` or `var` when variables are reassigned in Astro comp frontmatter","Avoid explicit import types in Astro files for better compat","Unused vars and imports are allowed in Astro files due to frontmatter constraints","No React-specific props like `className` and `htmlFor`. Use `class` and `for` instead"];var Jt=e=>{let t=[...Pe];return e&&(e.includes("react")&&t.push(...Re),e.includes("next")&&t.push(...Ae),e.includes("qwik")&&t.push(...Ue),e.includes("solid")&&t.push(...Fe),e.includes("svelte")&&t.push(...Ee),e.includes("vue")&&t.push(...$e),e.includes("angular")&&t.push(...Ie),e.includes("remix")&&t.push(...Oe),e.includes("astro")&&t.push(...De)),t.join(`
`)},Me=(e,t)=>{let s=Se[e],o=Jt(t),n=s.header?`${s.header}

${o}`:o,a=async()=>{let i=_t(s.path);if(i!=="."){let r=i.startsWith("./")?i.slice(2):i;await Mt(r,{recursive:!0})}};return{exists:()=>c(s.path),create:async()=>{await a(),await J(s.path,n)},update:async()=>{if(await a(),s.appendMode){if(!await c(s.path)){await J(s.path,n);return}let i=await Tt(s.path,"utf-8");if(i.includes(o.trim()))return;await J(s.path,`${i}

${o}`)}else await J(s.path,n)}}};m();import{readFile as Lt,writeFile as Te}from"fs/promises";import zt from"deepmerge";import{parse as Bt}from"jsonc-parser";var _e={$schema:"./node_modules/@biomejs/biome/configuration_schema.json",extends:["ultracite/core"]},oe=async()=>await c("./biome.json")?"./biome.json":"./biome.jsonc",L={exists:async()=>{let e=await oe();return c(e)},create:async e=>{let t=await oe(),s=["ultracite/core"];if(e?.frameworks&&e.frameworks.length>0)for(let n of e.frameworks)s.push(`ultracite/${n}`);let o={..._e,extends:s};return Te(t,JSON.stringify(o,null,2))},update:async e=>{let t=await oe(),s=await Lt(t,"utf-8"),n=Bt(s)||{},i=[...n.extends&&Array.isArray(n.extends)?n.extends:[]];if(i.includes("ultracite/core")||i.push("ultracite/core"),e?.frameworks&&e.frameworks.length>0)for(let g of e.frameworks){let d=`ultracite/${g}`;i.includes(d)||i.push(d)}n.extends=i;let r={$schema:_e.$schema},p=zt(n,r);await Te(t,JSON.stringify(p,null,2))}};m();import{spawnSync as qt}from"child_process";import{mkdir as Gt,readFile as Wt,writeFile as Je}from"fs/promises";import Ht from"deepmerge";import{parse as Vt}from"jsonc-parser";var ie={"editor.defaultFormatter":"esbenp.prettier-vscode","[javascript]":{"editor.defaultFormatter":"biomejs.biome"},"[typescript]":{"editor.defaultFormatter":"biomejs.biome"},"[javascriptreact]":{"editor.defaultFormatter":"biomejs.biome"},"[typescriptreact]":{"editor.defaultFormatter":"biomejs.biome"},"[json]":{"editor.defaultFormatter":"biomejs.biome"},"[jsonc]":{"editor.defaultFormatter":"biomejs.biome"},"[css]":{"editor.defaultFormatter":"biomejs.biome"},"[graphql]":{"editor.defaultFormatter":"biomejs.biome"},"typescript.tsdk":"node_modules/typescript/lib","editor.formatOnSave":!0,"editor.formatOnPaste":!0,"emmet.showExpandedAbbreviation":"never","editor.codeActionsOnSave":{"source.fixAll.biome":"explicit","source.organizeImports.biome":"explicit"}};var z="./.vscode/settings.json",F={exists:()=>c(z),create:async()=>{await Gt(".vscode",{recursive:!0}),await Je(z,JSON.stringify(ie,null,2))},update:async()=>{let e=await Wt(z,"utf-8"),s=Vt(e)||{},o=Ht(s,ie);await Je(z,JSON.stringify(o,null,2))},extension:()=>qt("code --install-extension biomejs.biome",{stdio:"inherit",shell:!0})};m();import{mkdir as Yt,readFile as Kt,writeFile as Le}from"fs/promises";import Xt from"deepmerge";import{parse as Qt}from"jsonc-parser";var ae={formatter:"language_server",format_on_save:"on",languages:{JavaScript:{formatter:{language_server:{name:"biome"}},code_actions_on_format:{"source.fixAll.biome":!0,"source.organizeImports.biome":!0}},TypeScript:{formatter:{language_server:{name:"biome"}},code_actions_on_format:{"source.fixAll.biome":!0,"source.organizeImports.biome":!0}},JSX:{formatter:{language_server:{name:"biome"}},code_actions_on_format:{"source.fixAll.biome":!0,"source.organizeImports.biome":!0}},TSX:{formatter:{language_server:{name:"biome"}},code_actions_on_format:{"source.fixAll.biome":!0,"source.organizeImports.biome":!0}}},lsp:{"typescript-language-server":{settings:{typescript:{preferences:{includePackageJsonAutoImports:"on"}}}}}};var B="./.zed/settings.json",q={exists:()=>c(B),create:async()=>{await Yt(".zed",{recursive:!0}),await Le(B,JSON.stringify(ae,null,2))},update:async()=>{let e=await Kt(B,"utf-8"),s=Qt(e)||{},o=Xt(s,ae);await Le(B,JSON.stringify(o,null,2))}};re();ce();de();m();import{readFile as ks,writeFile as Qe}from"fs/promises";import xs from"deepmerge";import{parse as Ns}from"jsonc-parser";var Ze={compilerOptions:{strictNullChecks:!0}},H="./tsconfig.json",V={exists:()=>c(H),create:()=>Qe(H,JSON.stringify(Ze,null,2)),update:async()=>{let e=await ks(H,"utf-8"),s=Ns(e)||{},o=xs(s,Ze);await Qe(H,JSON.stringify(o,null,2))}};m();var et=w.devDependencies["@biomejs/biome"],tt=w.version,Ps=async(e,t=!0)=>{let s=f();s.start("Installing dependencies...");let o=[`ultracite@${tt}`,`@biomejs/biome@${et}`];if(t)for(let n of o)await js(n,{packageManager:e,workspace:await h()});else await R({devDependencies:{"@biomejs/biome":et,ultracite:tt}});s.stop("Dependencies installed.")},Rs=async()=>{let e=f();if(e.start("Checking for tsconfig.json..."),await V.exists()){e.message("tsconfig.json found, updating..."),await V.update(),e.stop("tsconfig.json updated.");return}e.message("tsconfig.json not found, creating..."),await V.create(),e.stop("tsconfig.json created.")},As=async()=>{let e=f();if(e.start("Checking for .vscode/settings.json..."),await F.exists()){e.message("settings.json found, updating..."),await F.update(),e.stop("settings.json updated.");return}e.message("settings.json not found, creating..."),await F.create(),e.message("settings.json created."),e.message("Installing Biome extension...");try{F.extension(),e.stop("settings.json created.")}catch(t){e.stop(`Failed to install Biome extension (${t}), but continuing...`)}},Us=async()=>{let e=f();if(e.start("Checking for .zed/settings.json..."),await q.exists()){e.message("settings.json found, updating..."),await q.update(),e.stop("settings.json updated.");return}e.message("settings.json not found, creating..."),await q.create(),e.message("settings.json created. Install the Biome extension: https://biomejs.dev/reference/zed/")},Fs=async e=>{let t=f();if(t.start("Checking for Biome configuration..."),await L.exists()){t.message("Biome configuration found, updating..."),await L.update({frameworks:e}),t.stop("Biome configuration updated.");return}t.message("Biome configuration not found, creating..."),await L.create({frameworks:e}),t.stop("Biome configuration created.")},Es=async(e,t=!0)=>{let s=f();if(s.start("Initializing pre-commit hooks..."),s.message("Installing Husky..."),t?await C.install(e):await R({devDependencies:{husky:"latest"}}),await C.exists()){s.message("Pre-commit hook found, updating..."),await C.update(e),s.stop("Pre-commit hook updated.");return}s.message("Pre-commit hook not found, creating..."),await C.create(e),s.stop("Pre-commit hook created.")},$s=async(e,t=!0)=>{let s=f();if(s.start("Initializing lefthook..."),s.message("Installing lefthook..."),t?await j.install(e):await R({devDependencies:{lefthook:"latest"}}),await j.exists()){s.message("lefthook.yml found, updating..."),await j.update(e),s.stop("lefthook.yml updated.");return}s.message("lefthook.yml not found, creating..."),await j.create(e),s.stop("lefthook.yml created.")},Is=async(e,t=!0)=>{let s=f();if(s.start("Initializing lint-staged..."),s.message("Installing lint-staged..."),t?await S.install(e):await R({devDependencies:{"lint-staged":"latest"}}),await S.exists()){s.message("lint-staged found, updating..."),await S.update(e),s.stop("lint-staged updated.");return}s.message("lint-staged not found, creating..."),await S.create(e),s.stop("lint-staged created.")},Os=async(e,t,s)=>{let o=f();o.start(`Checking for ${t}...`);let n=Me(e,s);if(await n.exists()){o.message(`${t} found, updating...`),await n.update(),o.stop(`${t} updated.`);return}o.message(`${t} not found, creating...`),await n.create(),o.stop(`${t} created.`)},Ds=async e=>{let t=f();t.start("Removing Prettier dependencies and configuration...");try{let s=await se.remove(e);s.packagesRemoved.length>0&&t.message(`Removed Prettier packages: ${s.packagesRemoved.join(", ")}`),s.filesRemoved.length>0&&t.message(`Removed config files: ${s.filesRemoved.join(", ")}`),s.vsCodeCleaned&&t.message("Cleaned VS Code settings"),t.stop("Prettier removed successfully.")}catch{t.stop("Failed to remove Prettier completely, but continuing...")}},Ms=async e=>{let t=f();t.start("Removing ESLint dependencies and configuration...");try{let s=await te.remove(e);s.packagesRemoved.length>0&&t.message(`Removed ESLint packages: ${s.packagesRemoved.join(", ")}`),s.filesRemoved.length>0&&t.message(`Removed config files: ${s.filesRemoved.join(", ")}`),s.vsCodeCleaned&&t.message("Cleaned VS Code settings"),t.stop("ESLint removed successfully.")}catch{t.stop("Failed to remove ESLint completely, but continuing...")}},st=async e=>{Cs(ge);try{let t=e??{},{pm:s}=t;if(!s){let d=await Ss(x.cwd());if(!d)throw new Error("No package manager specified or detected");if(d.warnings)for(let u of d.warnings)Y.warn(u);Y.info(`Detected lockfile, using ${d.name}`),s=d.name}let o=t.migrate?.includes("prettier"),n=t.migrate?.includes("eslint");if(o===void 0||n===void 0){let d=[];if(o===void 0&&await se.hasPrettier()&&d.push({label:"Remove Prettier (dependencies, config files, VS Code settings)",value:"prettier"}),n===void 0&&await te.hasEsLint()&&d.push({label:"Remove ESLint (dependencies, config files, VS Code settings)",value:"eslint"}),d.length>0){let u=await D({message:"Remove existing formatters/linters (recommended for clean migration)?",options:d,required:!1});O(u)&&(I("Operation cancelled."),x.exit(0)),o===void 0&&(o=u.includes("prettier")),n===void 0&&(n=u.includes("eslint"))}}let a=t.frameworks;if(a===void 0)if(t.pm||t.editors||t.agents||t.integrations!==void 0||t.migrate!==void 0)a=[];else{let u=await D({message:"Which frameworks are you using (optional)?",options:[{label:"React",value:"react"},{label:"Next.js",value:"next"},{label:"Solid",value:"solid"},{label:"Vue",value:"vue"},{label:"Svelte",value:"svelte"},{label:"Qwik",value:"qwik"},{label:"Angular",value:"angular"},{label:"Remix / TanStack Router / React Router",value:"remix"},{label:"Astro",value:"astro"}],required:!1});O(u)&&(I("Operation cancelled."),x.exit(0)),a=u}let i=t.editors;if(!i){let d=await D({message:"Which editors do you want to configure (recommended)?",options:[{label:"VSCode / Cursor / Windsurf",value:"vscode"},{label:"Zed",value:"zed"}],required:!1});O(d)&&(I("Operation cancelled."),x.exit(0)),i=d}let r=t.agents,p={"vscode-copilot":"GitHub Copilot (VSCode)",cursor:"Cursor",windsurf:"Windsurf",zed:"Zed",claude:"Claude Code",codex:"OpenAI Codex / Jules / OpenCode",kiro:"Kiro IDE",cline:"Cline",amp:"AMP",aider:"Aider","firebase-studio":"Firebase Studio","open-hands":"Open Hands","gemini-cli":"Gemini CLI",junie:"Junie",augmentcode:"Augment Code","kilo-code":"Kilo Code",goose:"Codename Goose","roo-code":"Roo Code"};if(!r){let d=await D({message:"Which agents do you want to enable (optional)?",options:Object.entries(p).map(([u,nt])=>({value:u,label:nt})),required:!1});O(d)&&(I("Operation cancelled."),x.exit(0)),r=d}let g=t.integrations;if(g===void 0)if(t.pm||t.editors||t.agents||t.migrate!==void 0)g=[];else{let u=await D({message:"Would you like any of the following (optional)?",options:[{label:"Husky pre-commit hook",value:"husky"},{label:"Lefthook pre-commit hook",value:"lefthook"},{label:"Lint-staged",value:"lint-staged"}],required:!1});O(u)&&(I("Operation cancelled."),x.exit(0)),g=u}o&&await Ds(s),n&&await Ms(s),await Ps(s,!t.skipInstall),await Rs(),await Fs(a),i?.includes("vscode")&&await As(),i?.includes("zed")&&await Us();for(let d of r??[])await Os(d,p[d],a);g?.includes("husky")&&await Es(s,!t.skipInstall),g?.includes("lefthook")&&await $s(s,!t.skipInstall),g?.includes("lint-staged")&&await Is(s,!t.skipInstall),Y.success("Successfully initialized Ultracite configuration!")}catch(t){let s=t instanceof Error?t.message:"Unknown error";Y.error(`Failed to initialize Ultracite configuration: ${s}`),x.exit(1)}};var N=Ts.meta().create(),Js=N.router({init:N.procedure.meta({description:"Initialize Ultracite in the current directory"}).input(l.object({pm:l.enum(v.packageManagers).optional().describe("Package manager to use"),editors:l.array(l.enum(v.editorConfigs)).optional().describe("Editors to configure"),agents:l.array(l.enum(v.agents)).optional().describe("Agents to enable"),frameworks:l.array(l.enum(v.frameworks)).optional().describe("Frameworks being used"),integrations:l.array(l.enum(v.integrations)).optional().describe("Additional integrations to enable"),migrate:l.array(l.enum(v.migrations)).optional().describe("Migration tools to remove (e.g., eslint, prettier). Removes dependencies, config files, and editor settings."),skipInstall:l.boolean().default(!1).describe("Skip installing dependencies")})).mutation(async({input:e})=>{await st(e)}),check:N.procedure.meta({description:"Run Biome linter without fixing files"}).input(l.array(l.string()).optional().default([]).describe("specific files to lint")).query(({input:e})=>{ee(e)}),fix:N.procedure.meta({description:"Run Biome linter and fixes files"}).input(l.tuple([l.array(l.string()).optional().default([]).describe("specific files to format"),l.object({unsafe:l.boolean().optional().describe("apply unsafe fixes")})])).mutation(({input:e})=>{let[t,s]=e;ne(t,{unsafe:s.unsafe})}),doctor:N.procedure.meta({description:"Verify your Ultracite setup and check for issues"}).query(async()=>{await Ce()}),lint:N.procedure.meta({description:"\u26A0\uFE0F DEPRECATED: Use 'check' instead - Run Biome linter without fixing files"}).input(l.array(l.string()).optional().default([]).describe("specific files to lint")).query(({input:e})=>{console.warn("\u26A0\uFE0F  Warning: 'lint' command is deprecated. Please use 'check' instead."),ee(e)}),format:N.procedure.meta({description:"\u26A0\uFE0F DEPRECATED: Use 'fix' instead - Run Biome linter and fixes files"}).input(l.tuple([l.array(l.string()).optional().default([]).describe("specific files to format"),l.object({unsafe:l.boolean().optional().describe("apply unsafe fixes")})])).mutation(({input:e})=>{let[t,s]=e;console.warn("\u26A0\uFE0F  Warning: 'format' command is deprecated. Please use 'fix' instead."),ne(t,{unsafe:s.unsafe})})}),Ls=_s({router:Js,name:w.name,version:w.version,description:w.description});process.env.VITEST||Ls.run();export{Js as router};
