/// <reference types="node" />
/// <reference types="node" />
import { ApiFromModules, Expand, FunctionReference, GenericActionCtx, GenericDataModel, GenericMutationCtx, GenericQueryCtx } from "convex/server";
import { GenericId, Infer } from "convex/values";
import { api } from "../component/_generated/api";
import { S3Client } from "@aws-sdk/client-s3";
import { r2ConfigValidator } from "../shared";
export type R2Callbacks = {
    onSyncMetadata?: FunctionReference<"mutation", "internal", {
        bucket: string;
        key: string;
        isNew: boolean;
    }>;
};
export declare const DEFAULT_BATCH_SIZE = 10;
export type ClientApi = ApiFromModules<{
    client: ReturnType<R2["clientApi"]>;
}>["client"];
type RunQueryCtx = {
    runQuery: GenericQueryCtx<GenericDataModel>["runQuery"];
};
type RunMutationCtx = {
    runQuery: GenericQueryCtx<GenericDataModel>["runQuery"];
    runMutation: GenericMutationCtx<GenericDataModel>["runMutation"];
};
type RunActionCtx = {
    runAction: GenericActionCtx<GenericDataModel>["runAction"];
    runQuery: GenericQueryCtx<GenericDataModel>["runQuery"];
    runMutation: GenericMutationCtx<GenericDataModel>["runMutation"];
};
export declare class R2 {
    component: UseApi<typeof api>;
    options: {
        R2_BUCKET?: string;
        R2_ENDPOINT?: string;
        R2_ACCESS_KEY_ID?: string;
        R2_SECRET_ACCESS_KEY?: string;
        defaultBatchSize?: number;
    };
    readonly config: Infer<typeof r2ConfigValidator>;
    readonly r2: S3Client;
    /**
     * Backend API for the R2 component.
     * Responsible for exposing the `client` API to the client, and having
     * convenience methods for interacting with the component from the backend.
     *
     * Typically used like:
     *
     * ```ts
     * const r2 = new R2(components.r2);
     * export const {
     * ... // see {@link clientApi} docstring for details
     * } = r2.clientApi({...});
     * ```
     *
     * @param component - Generally `components.r2` from
     * `./_generated/api` once you've configured it in `convex.config.ts`.
     * @param options - Optional config object, most properties usually set via
     * environment variables.
     *   - `R2_BUCKET` - The bucket to use for the R2 component.
     *   - `R2_ENDPOINT` - The endpoint to use for the R2 component.
     *   - `R2_ACCESS_KEY_ID` - The access key ID to use for the R2 component.
     *   - `R2_SECRET_ACCESS_KEY` - The secret access key to use for the R2 component.
     *   - `defaultBatchSize` - The default batch size to use for pagination.
     */
    constructor(component: UseApi<typeof api>, options?: {
        R2_BUCKET?: string;
        R2_ENDPOINT?: string;
        R2_ACCESS_KEY_ID?: string;
        R2_SECRET_ACCESS_KEY?: string;
        defaultBatchSize?: number;
    });
    /**
     * Get a signed URL for serving an object from R2.
     *
     * @param key - The R2 object key.
     * @param options - Optional config object.
     *   - `expiresIn` - The number of seconds until the URL expires (default: 900, max: 604800 for 7 days).
     * @returns A promise that resolves to a signed URL for the object.
     */
    getUrl(key: string, options?: {
        expiresIn?: number;
    }): Promise<string>;
    /**
     * Generate a signed URL for uploading an object to R2.
     *
     * @param customKey (optional) - A custom R2 object key to use. Must be unique.
     * @returns A promise that resolves to an object with the following fields:
     *   - `key` - The R2 object key.
     *   - `url` - A signed URL for uploading the object.
     */
    generateUploadUrl(customKey?: string): Promise<{
        key: string;
        url: string;
    }>;
    /**
     * Store a blob in R2 and sync the metadata to Convex.
     *
     * @param ctx - A Convex action context.
     * @param blob - The blob to store.
     * @param opts - Optional config object.
     *   - `key` - A custom R2 object key to use (uuid if not provided).
     *   - `type` - The MIME type of the blob (will be inferred if not provided).
     * @returns A promise that resolves to the key of the stored object.
     */
    store(ctx: RunActionCtx, file: Uint8Array | Buffer | Blob, opts?: string | {
        key?: string;
        type?: string;
    }): Promise<string>;
    /**
     * Retrieve R2 object metadata and store in Convex.
     *
     * @param ctx - A Convex action context.
     * @param key - The R2 object key.
     * @returns A promise that resolves when the metadata is synced.
     */
    syncMetadata(ctx: RunActionCtx, key: string): Promise<void>;
    /**
     * Retrieve R2 object metadata from Convex.
     *
     * @param ctx - A Convex query context.
     * @param key - The R2 object key.
     * @returns A promise that resolves to the metadata for the object.
     */
    getMetadata(ctx: RunQueryCtx, key: string): Promise<{
        url: string;
        bucketLink: string;
        key: string;
        sha256?: string | undefined;
        contentType?: string | undefined;
        size?: number | undefined;
        bucket: string;
        lastModified: string;
        link: string;
    } | null>;
    /**
     * Retrieve all metadata from Convex for a given bucket.
     *
     * @param ctx - A Convex query context.
     * @param limit (optional) - The maximum number of documents to return.
     * @returns A promise that resolves to an array of metadata documents.
     */
    listMetadata(ctx: RunQueryCtx, limit?: number, cursor?: string | null): Promise<{
        page: {
            url: string;
            bucketLink: string;
            key: string;
            sha256?: string | undefined;
            contentType?: string | undefined;
            size?: number | undefined;
            bucket: string;
            lastModified: string;
            link: string;
        }[];
        isDone: boolean;
        continueCursor: string;
        splitCursor?: string | null | undefined;
        pageStatus?: "SplitRecommended" | "SplitRequired" | null | undefined;
    }>;
    /**
     * Delete an object from R2.
     *
     * @param ctx - A Convex action context.
     * @param key - The R2 object key.
     * @returns A promise that resolves when the object is deleted.
     */
    deleteObject(ctx: RunMutationCtx, key: string): Promise<void>;
    /**
     * Expose the client API to the client for use with the `useUploadFile` hook.
     * If you export these in `convex/r2.ts`, pass `api.r2`
     * to the `useUploadFile` hook.
     *
     * It allows you to define optional read, upload, and delete permissions.
     *
     * You can pass the optional type argument `<DataModel>` to have the `ctx`
     * parameter specific to your tables.
     *
     * ```ts
     * import { DataModel } from "./convex/_generated/dataModel";
     * // ...
     * export const { ... } = r2.clientApi<DataModel>({...});
     * ```
     *
     * To define just one function to use for both, you can define it like this:
     * ```ts
     * async function checkPermissions(ctx: QueryCtx, id: string) {
     *   const user = await getAuthUser(ctx);
     *   if (!user || !(await canUserAccessDocument(user, id))) {
     *     throw new Error("Unauthorized");
     *   }
     * }
     * ```
     * @param opts - Optional callbacks.
     * @returns functions to export, so the `useUploadFile` hook can use them, or
     * for direct use in your own client code.
     */
    clientApi<DataModel extends GenericDataModel>(opts?: {
        checkReadKey?: (ctx: GenericQueryCtx<DataModel>, bucket: string, key: string) => void | Promise<void>;
        checkReadBucket?: (ctx: GenericQueryCtx<DataModel>, bucket: string) => void | Promise<void>;
        checkUpload?: (ctx: GenericQueryCtx<DataModel>, bucket: string) => void | Promise<void>;
        checkDelete?: (ctx: GenericQueryCtx<DataModel>, bucket: string, key: string) => void | Promise<void>;
        onUpload?: (ctx: GenericMutationCtx<DataModel>, bucket: string, key: string) => void | Promise<void>;
        onSyncMetadata?: (ctx: GenericMutationCtx<DataModel>, args: {
            bucket: string;
            key: string;
            isNew: boolean;
        }) => void | Promise<void>;
        onDelete?: (ctx: GenericMutationCtx<DataModel>, bucket: string, key: string) => void | Promise<void>;
        callbacks?: R2Callbacks;
    }): {
        /**
         * Generate a signed URL for uploading an object to R2.
         */
        generateUploadUrl: import("convex/server").RegisteredMutation<"public", {}, Promise<{
            key: string;
            url: string;
        }>>;
        /**
         * Retrieve R2 object metadata and store in Convex.
         */
        syncMetadata: import("convex/server").RegisteredMutation<"public", {
            key: string;
        }, Promise<void>>;
        onSyncMetadata: import("convex/server").RegisteredMutation<"internal", {
            key: string;
            bucket: string;
            isNew: boolean;
        }, Promise<void>>;
        /**
         * Retrieve metadata for an R2 object from Convex.
         */
        getMetadata: import("convex/server").RegisteredQuery<"public", {
            key: string;
        }, Promise<{
            url: string;
            bucketLink: string;
            key: string;
            sha256?: string | undefined;
            contentType?: string | undefined;
            size?: number | undefined;
            bucket: string;
            lastModified: string;
            link: string;
        } | null>>;
        /**
         * Retrieve all metadata for a given bucket from Convex.
         */
        listMetadata: import("convex/server").RegisteredQuery<"public", {
            paginationOpts: {
                id?: number | undefined;
                endCursor?: string | null | undefined;
                maximumRowsRead?: number | undefined;
                maximumBytesRead?: number | undefined;
                numItems: number;
                cursor: string | null;
            };
        }, Promise<{
            page: {
                url: string;
                bucketLink: string;
                key: string;
                sha256?: string | undefined;
                contentType?: string | undefined;
                size?: number | undefined;
                bucket: string;
                lastModified: string;
                link: string;
            }[];
            isDone: boolean;
            continueCursor: string;
            splitCursor?: string | null | undefined;
            pageStatus?: "SplitRecommended" | "SplitRequired" | null | undefined;
        }>>;
        /**
         * Delete an object from R2 and remove its metadata from Convex.
         */
        deleteObject: import("convex/server").RegisteredMutation<"public", {
            key: string;
        }, Promise<void>>;
    };
}
export type OpaqueIds<T> = T extends GenericId<infer _T> ? string : T extends (infer U)[] ? OpaqueIds<U>[] : T extends object ? {
    [K in keyof T]: OpaqueIds<T[K]>;
} : T;
export type UseApi<API> = Expand<{
    [mod in keyof API]: API[mod] extends FunctionReference<infer FType, "public", infer FArgs, infer FReturnType, infer FComponentPath> ? FunctionReference<FType, "internal", OpaqueIds<FArgs>, OpaqueIds<FReturnType>, FComponentPath> : UseApi<API[mod]>;
}>;
export {};
//# sourceMappingURL=index.d.ts.map